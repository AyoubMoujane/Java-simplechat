// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com package client;import com.lloseng.ocsf.client.*;import common.*;import java.io.*;import java.lang.ArrayIndexOutOfBoundsException;import java.util.Observable;import java.util.Observer;;/** * This class overrides some of the methods defined in the abstract * superclass in order to give more functionality to the client. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave; * @author Fran&ccedil;ois B&eacute;langer * @version July 2000 */public class ChatClient implements Observer{	// Class variables ***************************************************	/**	 * Indicates a close of the connection to server.	 */	public static final String CONNECTION_CLOSED = "#OC:Connection closed.";	/**	 * Indicates establishment of a connection to server.	 */	public static final String CONNECTION_ESTABLISHED = "#OC:Connection established.";  //Instance variables **********************************************    /**   * The interface type variable.  It allows the implementation of    * the display method in the client.   */  ChatIF clientUI;  ObservableClient communicationService;    // Variable that holds de name chosen by the user when created    String name;    /**   * Hook method called after the connection has been closed.   * The default implementation does nothing. The method   * may be overriden by subclasses to perform special processing   * such as cleaning up and terminating, or attempting to   * reconnect.   */  protected void connectionClosed() {	  clientUI.display("Connection closed correctly");  }  /**   * Hook method called each time an exception is thrown by the   * client's thread that is waiting for messages from the server.   * The method may be overridden by subclasses.   *   * @param exception the exception raised.   */  protected void connectionException(Exception exception) {	  clientUI.display("Lost connection with the server");	  quit();  }    /**   * Hook method called after a connection has been established.   * The default implementation does nothing.   * It may be overridden by subclasses to do anything they wish.   */  protected void connectionEstablished() {	  clientUI.display("Connection established successfully");  }     //Constructors ****************************************************    /**   * Constructs an instance of the chat client.   *   * @param host The server to connect to.   * @param port The port number to connect on.   * @param clientUI The interface type variable.   */    public ChatClient(String host, int port, ChatIF clientUI)     throws IOException   {//    super(host, port); //Call the superclass constructor    this.clientUI = clientUI;//    openConnection();	  communicationService = new ObservableClient(host, port);	  communicationService.addObserver(this);  }    //Instance methods ************************************************      /**   * This method handles all data that comes in from the server.   *   * @param msg The message from the server.   */  public void handleMessageFromServer(Object msg)   {	  String[] msgSplit = ((String) msg).split(" ");		if(((String) msg).startsWith("#")){			if(((String) msg).startsWith("#quit")){				quit();			}			else if(((String) msg).startsWith("#logoff")) {				try			    {					communicationService.closeConnection();			    }			    catch(IOException e) {}			}		}		else {		    clientUI.display(msg.toString());		}  }    public void setName(String name) {	  this.name=name;  }  public void sendToServer(String message){  	try{		communicationService.sendToServer(message);	}  	catch(IOException e){		clientUI.display				("Could not send message to server.  Terminating client.");		quit();	}  }    public String getName() {	 return name;  }  /**   * This method handles all data coming from the UI               *   * @param message The message from the UI.       */  public void handleMessageFromClientUI(String message)  {	  // The client enters a command	  if(message.startsWith("#")) {		  String[] msgSplit = message.split(" ");		  if(message.startsWith("#quit")) {			  if(communicationService.isConnected()) {				  try				    {						communicationService.sendToServer(message);				    }				    catch(IOException e)				    {				      clientUI.display				        ("Could not send message to server.  Terminating client.");				      quit();				    }			  } 			  else {				  quit();			  }			  		  }		  else if(message.startsWith("#logoff")) {			  if(communicationService.isConnected()) {				  try				    {						communicationService.sendToServer(message);				    }				    catch(IOException e)				    {				      clientUI.display				        ("Could not send message to server.  Terminating client.");				      quit();				    }			  }			  else {				  clientUI.display("Already logged off");			  }			  			}		  else if(message.startsWith("#sethost")) {				if(communicationService.isConnected()) {					clientUI.display			        ("Can't use this command, you already are connected");				} 				else {					try {						communicationService.setHost(msgSplit[1]);					}					catch(ArrayIndexOutOfBoundsException e) {						clientUI.display("Please respect the format #sethost <hostname>");					}				}			}		  else if(message.startsWith("#setport")) {				if(communicationService.isConnected()) {					clientUI.display			        ("Can't use this command, you already are connected");				} 				else {					try {						communicationService.setPort(Integer.parseInt(msgSplit[1]));						clientUI.display("New port is: " + Integer.parseInt(msgSplit[1]));					}					catch(ArrayIndexOutOfBoundsException e) {						clientUI.display("Please respect the format #setport <port>");					}					catch(NumberFormatException e) {						clientUI.display("Please respect the format #setport <port> (the port is a number)");					}				}			}		  else if(message.startsWith("#login")) {				if(communicationService.isConnected()) {					clientUI.display			        ("Can't use this command, you already are connected");				} 				else {					try {						communicationService.openConnection();						sendToServer("#login "+name);					}					catch(IOException e) {						clientUI.display				        ("Can't connect, please check hostname and port");					}				}			}		  else if(message.startsWith("#gethost")) {				clientUI.display("Host: "+ communicationService.getHost());			}		  else if(message.startsWith("#getport")) {				clientUI.display("Port :" + Integer.toString(communicationService.getPort()));			}		  else {			  clientUI.display		        ("Unknown command");		  }	  }	  else 	  {		  try		    {				communicationService.sendToServer(message);		    }		    catch(IOException e)		    {		      clientUI.display		        ("Could not send message to server.  Terminating client.");		      quit();		    }	  }      }    /**   * This method terminates the client.   */  public void quit()  {    try    {		communicationService.closeConnection();    }    catch(IOException e) {}    System.exit(0);  }	/**	 * This method is called whenever the observed object is changed. An	 * application calls an {@code Observable} object's	 * {@code notifyObservers} method to have all the object's	 * observers notified of the change.	 *	 * @param o   the observable object.	 * @param arg an argument passed to the {@code notifyObservers}	 */	@Override	public void update(Observable o, Object arg) {		String message = (String) arg;		if(CONNECTION_CLOSED.contentEquals(message)){			connectionClosed();		}		else if (CONNECTION_ESTABLISHED.contentEquals(message)){			connectionEstablished();		}		else {			handleMessageFromServer(message);		}	}}//End of ChatClient class